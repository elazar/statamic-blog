---
id: cd247af4-4629-4501-a153-82c5b1ba4cfd
title: 'On What To Learn'
excerpt: 'An aspect of mentorship that I''ve enjoyed is the questions I receive from my apprentices. One rather important such question came up recently.'
author:
  - 58305525-d036-4657-bce6-1b7091fe031d
updated_by: 58305525-d036-4657-bce6-1b7091fe031d
updated_at: 1619571896
tags:
  - professional-development
---
An aspect that I've enjoyed of participating as a mentor in the [PHP Mentoring](http://phpmentoring.org/ "PHP Mentoring | Vision") program is the interesting and provocative questions I receive from my apprentices. One such question, and in my opinion a rather important one, came up recently:

> "One thing I feel I struggle with is wanting to take on too much. There are so many languages out there, and I would love to learn all of them... How do you balance your time while still staying on top of the game? In your opinion, which languages do you think are the best to focus on?"

This will probably sound cliche, over-dramatic, overly philosophical, or what have you, but understand that I'm simply stating it as fact to reinforce the point: **perhaps our biggest limitation as a species is that we are bound by time**. We exist for a very brief period. With every moment that passes, the state of our world is subject to one constant condition: change. A skill you learn today may be obsolete a few years from now. A memory may be with you decades from when it's first formed, continuing to color your views and experiences.

Some of us — perhaps the best of us — would love nothing more than to have the time and capacity to learn everything that the world has to offer, but that's not within our physical capabilities. Our only other option is consciously limiting what we learn and what we focus on. It's regrettable that we must do this, in particular because the acquisition of knowledge is a noble goal, but it is the way of things. To at least some degree, we have to specialize our knowledge.

The question of what to learn is one I've pondered before this person ever posed it to me. At a time when I lacked a good answer, I did what I normally do in such situations: I consulted my betters, in this case [Dr. Alan Perlis](http://en.wikipedia.org/wiki/Alan_Perlis "Alan Perlis - Wikipedia, the free encyclopedia"). Dr. Perlis was an American computer scientist with many accomplishments to his name, most notably his pioneering work in programming languages.

In 1982 — the year of my birth, fittingly — Dr. Perlis published a work entitled ["Epigrams on Programming"](http://pu.inf.uni-tuebingen.de/users/klaeren/epigrams.html "Epigrams on Programming") in the monthly newsletter of [SIGPLAN](http://www.sigplan.org/ "SIGPLAN | To explore programming language concepts and tools focusing on design, implementation and efficient use."), a special interest group of the [Association for Computing Machinery](http://www.acm.org/ "Welcome — Association for Computing Machinery") focused on programming languages. One quote from this publication stood out to me:

> 19: A language that doesn't affect the way you think about programming, is not worth knowing.

I don't know that I necessarily agree with Dr. Perlis on this point in all cases, but it does provide a rule of thumb of sorts when considering what to invest time and effort in learning. Programming languages aren't especially different from spoken languages in this respect: learning one Latin-based language may help you to learn others, but learning one that isn't Latin-based such as Russian or Chinese increases your overall understanding of language.

When I was in college, I took a [course on programming languages](http://web.cacs.louisiana.edu/~mgr/450/index.html "CMPS 450 001") specifically aimed at increasing our breadth of knowledge about them. We wrote a [parser](http://en.wikipedia.org/wiki/Parsing#Parser "Parsing - Wikipedia, the free encyclopedia") for a subset of [ALGOL 60](http://en.wikipedia.org/wiki/ALGOL_60 "ALGOL 60 - Wikipedia, the free encyclopedia") (a language for which Dr. Perlis was a member of the development team) in [SNOBOL](http://en.wikipedia.org/wiki/SNOBOL "SNOBOL - Wikipedia, the free encyclopedia"), a [tokenizer](http://en.wikipedia.org/wiki/Lexical_analysis#Tokenizer "Lexical analysis - Wikipedia, the free encyclopedia") for [ML](http://en.wikipedia.org/wiki/Standard_ML "Standard ML - Wikipedia, the free encyclopedia") in [ML](http://en.wikipedia.org/wiki/Standard_ML "Standard ML - Wikipedia, the free encyclopedia"), and an [object-oriented](http://en.wikipedia.org/wiki/Object-oriented_programming "Object-oriented programming - Wikipedia, the free encyclopedia") rendition of a [switch statement](http://en.wikipedia.org/wiki/Switch_statement "Switch statement - Wikipedia, the free encyclopedia") in [Smalltalk](http://en.wikipedia.org/wiki/Smalltalk "Smalltalk - Wikipedia, the free encyclopedia"). These aren't [hipster](http://en.wikipedia.org/wiki/Hipster_(contemporary_subculture) "Hipster (contemporary subculture) - Wikipedia, the free encyclopedia") programming languages; the thought that went into their development formed the foundations of modern programming and paved the way for the languages we use today. Each of these proved interesting to study in their own way and fulfilled the goal of the course.

So, to come full circle, here are my reflections reduced to a few [epigrams](http://en.wikipedia.org/wiki/Epigram "Epigram - Wikipedia, the free encyclopedia") of my own:

1. Rein in your desire to learn everything while maintaining your desire to continue learning.
2. Focus your efforts on learning things that contribute to the quality of your understanding and of your craft.
3. Every once in a while, learn something just because you want to.
4. Make a point to sporadically have experiences in which learning is not your primary goal.

And one last parting thought: you can find [more and better words of wisdom](http://pragprog.com/the-pragmatic-programmer/extracts/tips "The Pragmatic Bookshelf | List of Tips") in [The Pragmatic Programmer](http://pragprog.com/book/tpp/the-pragmatic-programmer "The Pragmatic Bookshelf | The Pragmatic Programmer"). If you haven't read it, I highly recommend you make the time to do so.

My best,

Matt