---
id: 9a5eea29-a8bc-4bf6-ad4d-e73acbf50e97
title: 'The Yin and Yang of Typing'
excerpt: 'Without background in programming languages or computer science in general, it''s possible that typing systems are not something that have crossed your mind.'
author:
  - 58305525-d036-4657-bce6-1b7091fe031d
updated_by: 58305525-d036-4657-bce6-1b7091fe031d
updated_at: 1619483412
---
Without a little background in programming languages or computer science in general, it's entirely possible that [typing systems](https://en.wikipedia.org/wiki/Type_system "Type system - Wikipedia, the free encyclopedia") are not something that have crossed your mind. I thought I'd take a blog entry to share some of my thoughts on how it's affecting the creation and evolution of languages.

First of all, [Benjamin C. Pierce](https://en.wikipedia.org/wiki/Benjamin_C._Pierce "Benjamin C. Pierce - Wikipedia, the free encyclopedia") probably has [a point](https://en.wikipedia.org/wiki/Strong_typing#Interpretation "Strongly-typed programming language - Wikipedia, the free encyclopedia"): terminology used to refer to typing concepts is about as useful as buzzwords like [AJAX](https://en.wikipedia.org/wiki/Ajax_%28programming%29 "Ajax (programming) - Wikipedia, the free encyclopedia") or [Web 2.0](https://en.wikipedia.org/wiki/Web_2.0#Defining_.22Web_2.0.22 "Web 2.0 - Wikipedia, the free encyclopedia") these days. Be that as it may, I'm going to reach back into the recesses of what I recall from the [programming languages course](http://web.archive.org/web/20080724070148/http://louisiana.edu/Academic/Sciences/CMPS/curriculum/crsdesc/450.pdf "CMPS 450: Programming Languages") I took in college to recall some of this terminology.

If you aren't familiar with [static](https://en.wikipedia.org/wiki/Static_typing#Static_typing "Type system - Wikipedia, the free encyclopedia") versus [dynamic](https://en.wikipedia.org/wiki/Dynamic_typing#Dynamic_typing "Type system - Wikipedia, the free encyclopedia") typing or [strong](https://en.wikipedia.org/wiki/Strong_typing "Strongly-typed programming language - Wikipedia, the free encyclopedia") versus [weak](https://en.wikipedia.org/wiki/Weak_typing "Weak typing - Wikipedia, the free encyclopedia") typing, it may be worth it to read up on those before proceeding with the rest of this blog entry. Here are a few examples of each:

- Static/weak - [C](https://en.wikipedia.org/wiki/C_programming_language "C (programming language) - Wikipedia, the free encyclopedia")
- Static/strong - [Java](https://en.wikipedia.org/wiki/Java_programming_language "Java (programming language) - Wikipedia, the free encyclopedia")
- Dynamic/weak - [PHP](https://en.wikipedia.org/wiki/PHP "PHP - Wikipedia, the free encyclopedia")
- Dynamic/strong - [Python](https://en.wikipedia.org/wiki/Python_programming_language "Python (programming language) - Wikipedia, the free encyclopedia")

The line between strong versus weak typing seems to be blurred as languages like these evolve. The reason for this is that each side of typing has its advantages. Strong typing allows for compile-time checking, which can serve to eliminate human error, as well as performance optimizations from being aware of types at compile-time. They can also serve to make source code more intuitive to follow in some respects. Weak typing, on the other hand, can allow for higher levels of abstraction and, by proxy, the need for less code in order to allow identical operations to be executed on multiple types. It can also allow for things like [variable variables](https://www.php.net/manual/en/language.variables.variable.php "PHP: Variable variables - Manual"), [variable functions](https://www.php.net/manual/en/functions.variable-functions.php "PHP: Variable functions - Manual"), and other interesting features not possible in strongly-typed languages.

Yet languages on either side of the proverbial fence are drawing in strengths from the other side. Java, before limited to the flexibility that could be provided by [polymorphism](https://en.wikipedia.org/wiki/Polymorphism_%28computer_science%29 "Polymorphism (computer science) - Wikipedia, the free encyclopedia") while still maintaining strong typing, introduced [generics](https://docs.oracle.com/javase/1.5.0/docs/guide/language/generics.html "Generics") in 1.5, whereby typing was still enforced but a higher level of logic abstraction was enabled for developers. By the same token, PHP has had explicit [typecasting](https://www.php.net/manual/en/language.types.type-juggling.php#language.types.typecasting "PHP: Type Juggling - Manual") for a while and more recently in 5.1 introduced [type hinting](https://www.php.net/manual/en/language.oop5.typehinting.php "PHP: Type Hinting - Manual") for array and object types (which may extend to scalar types in later versions). C# in 3.5 adds [type inferencing](https://msmvps.com/blogs/senthil/archive/2007/11/19/type-inference-dynamic-typing.aspx "Type inference != Dynamic typing - the blog => anything goes"), which while it's only syntactic sugar at least alleviates the need for verbosity when performing the most common method of initialization (i.e. setting a variable of a given class to an object instance of that class, as opposed to one involving a subclass of one or more of the classes involved).

It's also becoming commonplace for dynamically typed language interpreters to get ported to Java and .NET in order to leverage the features of those languages and the native libraries of the host language in the existing execution environment. Take these examples for instance.

- [Quercus](http://quercus.caucho.com/) (Java) and [Phalanger](http://php-compiler.net/) (.NET) for [PHP](https://php.net/)
- [JRuby](http://www.jruby.org/) (Java) and [IronRuby](http://www.ironruby.net/) (.NET) for [Ruby](https://www.ruby-lang.org/)
- [Jython](http://www.jython.org/) (Java) and [IronPython](https://github.com/IronLanguages/ironpython2) (.NET) for [Python](https://python.org/)

In short, some level of control over typing is obviously a desired feature in any useful language. As well, I don't think a language can be truly useful without having a bit of both worlds to some degree. The reason for the existence of programming languages is to enable developers to control machines whose primary purpose is to manipulate data (and, as has been pointed out many times before, are stupid and do what we tell them to do). If control over said manipulation is hampered by the typing system, it hampers the effectiveness of the language. In this, I have to agree with [Ludwig Wittgenstein](https://en.wikiquote.org/wiki/Ludwig_Wittgenstein "Ludwig Wittgenstein - Wikiquote"), who said, "The limits of my language mean the limits of my world."