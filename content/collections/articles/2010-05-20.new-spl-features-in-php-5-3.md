---
id: c1a7004d-c41f-4f52-bc57-8087809ae4b4
title: 'New SPL Features in PHP 5.3'
excerpt: 'The SPL, or Standard PHP Library, is an often overlooked extension in the PHP core.'
author:
  - 58305525-d036-4657-bce6-1b7091fe031d
updated_by: 58305525-d036-4657-bce6-1b7091fe031d
updated_at: 1619571371
tags:
  - php
---
_Note: I've [written on this topic before](https://web.archive.org/web/20130805120049/http://blueparabola.com/blog/spl-deserves-some-reiteration "The SPL Deserves Some Reiteration | Blue Parabola, LLC"), but thought the subject warranted further more detailed discussion and a more comprehensive and up-to-date set of benchmarks. Hence, this post and [this presentation](http://www.slideshare.net/tobias382/new-spl-features-in-php-53 "New SPL Features in PHP 5.3"). Enjoy._

The [SPL](http://php.net/spl "PHP: SPL - Manual"), or Standard PHP Library, is an often overlooked extension in the PHP core. It first came on the scene in PHP 5 and a variety of [iterators](http://php.net/manual/en/spl.iterators.php "PHP: Iterators - Manual") constituted the majority of its initial offerings. Though the [iterator offerings were expanded in PHP 5.3](http://www.php.net/manual/en/migration53.classes.php "PHP: New Classes - Manual"), the particularly interesting additions to the SPL were several specialized [data structure](http://en.wikipedia.org/wiki/Data_structures "Data structure - Wikipedia, the free encyclopedia") [classes](http://php.net/manual/en/spl.datastructures.php "PHP: Datastructures - Manual"), the foundational concepts for which originate in the field of [computer science](http://en.wikipedia.org/wiki/Computer_science "Computer science - Wikipedia, the free encyclopedia"). In this post, I will provide an overview of these new classes and explain why and when they should be used.

### Arrays

While PHP has several data types, the ones that likely see the most frequent and varied use are [strings](http://php.net/manual/en/language.types.string.php "PHP: Strings - Manual") and [arrays](http://php.net/manual/en/language.types.array.php "PHP: Arrays - Manual"). They are the proverbial [duct tape](http://en.wikipedia.org/wiki/Duct_tape#Common_uses "Duct tape - Wikipedia, the free encyclopedia") and [WD-40](http://en.wikipedia.org/wiki/WD-40#Function "WD-40 - Wikipedia, the free encyclopedia") of PHP, respectively. Like arrays, SPL data structure classes are used to store composite (i.e. non-[scalar](http://en.wikipedia.org/wiki/Scalar_(computing) "Scalar (computing) - Wikipedia, the free encyclopedia")) data.

Now, that's not to say that every instance of an array in existing codebases should be replaced with an SPL container object. There are cases where its appropriate to use one over the other. Knowing the difference requires an understanding of how arrays work.

Within the C code that makes up the PHP interpreter, arrays are implemented as a data structure called a [hash table or hash map](http://en.wikipedia.org/wiki/Hash_table "Hash table - Wikipedia, the free encyclopedia"). When a value contained within an array is referenced by its index, PHP uses a [hashing function](https://git.php.net/?p=php-src.git;a=blob;f=Zend/zend_hash.h;hb=dd5c478be61a0ef94b54837cfa875c964356e14f#l228) to convert that index into a unique hash representing the location of the corresponding value within the array.

This hash map implementation enables arrays to store an arbitrary number of elements and provide access to all of those elements simultaneously using either numeric or string keys. Arrays are extremely fast for the capabilities they provide and are an excellent general purpose data structure.

### Fixed Arrays

In contrast to arrays, [`SplFixedArray`](http://php.net/manual/en/class.splfixedarray.php "PHP: SplFixedArray - Manual") functions more like [C arrays](http://www.cplusplus.com/doc/tutorial/arrays/ "Arrays") or [Java arrays](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html "Arrays (The Javaâ„¢ Tutorials > Learning the Java Language > Language Basics)") than [PHP arrays](http://php.net/manual/en/language.types.array.php "PHP: Arrays - Manual"). The maximum number of elements that it may contain is specified upon instantiation. While it is possible to change it later via the `setSize()` method, this negates the performance advantages of using it: because its size is fixed, it doesnt need to use a hashing function to resolve the position of elements within the array. **It makes sense to use fixed arrays when the number of elements to be stored is known in advance and the elements only need to be accessed by sequential position.**

`SplFixedArray` implements the [`Iterator`](http://php.net/manual/en/class.iterator.php "PHP: Iterator - Manual"), [`ArrayAccess`](http://php.net/manual/en/class.arrayaccess.php "PHP: ArrayAccess - Manual"), and [`Countable`](http://php.net/manual/en/class.countable.php "PHP: Countable - Manual") interfaces. `Iterator` allows it to be iterated using a [`foreach`](http://php.net/manual/en/control-structures.foreach.php "PHP: foreach - Manual") loop. `ArrayAccess` provides access to its elements using [array syntax](http://php.net/manual/en/language.types.array.php#language.types.array.syntax.modifying "PHP: Arrays - Manual") where elements are referred to using integer positions beginning at 0 as with enumerated arrays. `Countable` enables a list to be passed to the [`count()`](http://php.net/count "PHP: count - Manual") function like an array.

Aside from the inability to use it in place of arrays with [array functions](http://php.net/manual/en/ref.array.php "PHP: Array Functions - Manual"), instances of `SplFixedArray` function just like arrays for all intents and purposes. It's even possible to convert them to and from arrays using the [`toArray()`](http://php.net/manual/en/splfixedarray.toarray.php "PHP: SplFixedArray::toArray - Manual") and [`fromArray()`](http://php.net/manual/en/splfixedarray.fromarray.php "PHP: SplFixedArray::fromArray - Manual") methods respectively. However, it generally makes more sense to use `SplFixedArray` exclusively for each individual use case.

### Lists

In [computer science](http://en.wikipedia.org/wiki/Computer_science "Computer science - Wikipedia, the free encyclopedia"), a [list](http://en.wikipedia.org/wiki/List_(computing) "List (computing) - Wikipedia, the free encyclopedia") is defined as an ordered collection of values. A [linked list](http://en.wikipedia.org/wiki/Linked_list "Linked list - Wikipedia, the free encyclopedia") is a data structure in which each element in the list includes a reference to one or both of the elements on either side of it within the list. The term [doubly-linked list](http://en.wikipedia.org/wiki/Doubly-linked_list "Doubly-linked list - Wikipedia, the free encyclopedia") is used to refer to the latter case. In the SPL, this takes the form of the class [`SplDoublyLinkedList`](http://php.net/manual/en/class.spldoublylinkedlist.php "PHP: SplDoublyLinkedList - Manual").

Like `SplFixedArray`, `SplDoublyLinkedList` also implements the [`Iterator`](http://php.net/manual/en/class.iterator.php "PHP: Iterator - Manual"), [`ArrayAccess`](http://php.net/manual/en/class.arrayaccess.php "PHP: ArrayAccess - Manual"), and [`Countable`](http://php.net/manual/en/class.countable.php "PHP: Countable - Manual") interfaces. In addition to the methods that come with these interface implementations, elements can be added to or removed from the start or end of the list using its [`push()`](http://php.net/manual/en/spldoublylinkedlist.push.php "PHP: SplDoublyLinkedList::push - Manual"), [`pop()`](http://php.net/manual/en/spldoublylinkedlist.pop.php "PHP: SplDoublyLinkedList::pop - Manual"), [`shift()`](http://php.net/manual/en/spldoublylinkedlist.shift.php "PHP: SplDoublyLinkedList::shift - Manual") and [`unshift()`](http://php.net/manual/en/spldoublylinkedlist.unshift.php "PHP: SplDoublyLinkedList::unshift - Manual") methods, which correspond to the [`array_push()`](http://php.net/array_push "PHP: array_push - Manual"), [`array_pop()`](http://php.net/array_pop "PHP: array_pop - Manual"), [`array_shift()`](http://php.net/array_shift "PHP: array_shift - Manual"), and [`array_unshift()`](http://php.net/array_unshift "PHP: array_unshift - Manual") functions respectively. Unfortunately, as of PHP 5.3.4, theres no way to insert an element anywhere in the list other than at the beginning or the end. A [feature request](https://bugs.php.net/bug.php?id=48358 "PHP Bugs: #48358: SplDoublyLinkedList needs an insertAfterIterator() method or something similar") has been filed for this. Add a comment or vote to show support for its addition.

The elements at the start and end of the list are accessible via its [`top()`](http://php.net/manual/en/spldoublylinkedlist.top.php "PHP: SplDoublyLinkedList::top - Manual") and [`bottom()`](http://php.net/manual/en/spldoublylinkedlist.bottom.php "PHP: SplDoublyLinkedList::bottom - Manual") methods respectively, which correspond to the [`reset()`](http://php.net/manual/en/function.reset.php "PHP: reset - Manual") and [`end()`](http://php.net/manual/en/function.end.php "PHP: end - Manual") functions. Like `SplFixedArray`, elements can also be accessed arbitrarily by positional index using the array syntax granted by `ArrayAccess`. **It makes sense to use lists when the number of elements to be stored is not known in advance and the elements only need to be accessed by sequential position.**

### Stacks

[Stacks](http://en.wikipedia.org/wiki/Stack_(data_structure) "Stack (data structure) - Wikipedia, the free encyclopedia") are similar to lists with two major differences. First, elements can only be added to the top of the stack. Second, an element can only be accessed by taking it off the top of the stack. Because of these differences, the stack is often referred to as a Last-In-First-Out or [LIFO](http://en.wikipedia.org/wiki/LIFO_(computing) "LIFO (computing) - Wikipedia, the free encyclopedia") data structure. [`SplStack`](http://php.net/manual/en/class.splstack.php "PHP: SplStack - Manual") is the SPL stack implementation.

`SplStack` is a bit removed from the traditional definition of a stack. It extends `SplDoublyLinkedList` and inherits its abilities, some of which dont really apply to stacks. In order to enforce its restriction on how elements are accessed, `SplStack` overrides the [`setIteratorMode()`](http://php.net/manual/en/spldoublylinkedlist.setiteratormode.php "PHP: SplDoublyLinkedList::setIteratorMode - Manual") method of its parent class and implements [its own](http://php.net/manual/en/splstack.setiteratormode.php "PHP: SplStack::setIteratorMode - Manual") to prevent modification of the iteration direction. Both methods allow elements to be retained or removed as they are iterated.

**Use of stacks makes sense when the number of elements to be stored is not known in advance and the only element that must be accessible is the last one stored.** However, as of PHP 5.3.4, the performance of `SplStack` leaves something to be desired. Benchmarks included later in this provide an objective illustration of this, though the cause of the behavior remains unknown.

### Queues

[Queues](http://en.wikipedia.org/wiki/Queue_(data_structure) "Queue (data structure) - Wikipedia, the free encyclopedia") are also similar to lists, again with two major differences. First, elements can only be added (or enqueued) to the end of the queue. Second, an element can only be accessed by removing (or dequeueing) it from the beginning of the queue. For these reasons the queue is referred to as a First-In-First-Out or [FIFO](http://en.wikipedia.org/wiki/FIFO "FIFO - Wikipedia, the free encyclopedia") data structure. The [`SplQueue`](http://php.net/manual/en/class.splqueue.php "PHP: SplQueue - Manual") class implements this data structure in the SPL.

`SplQueue` follows suit with `SplStack` in extending `SplDoublyLinkedList`. Just as `SplStack` resultingly inherits some operations with at least questionable applicability, so too does `SplQueue`. Likewise, it overrides `setIteratorMode()` with [its own version](http://php.net/manual/en/splqueue.setiteratormode.php "PHP: SplQueue::setIteratorMode - Manual") to restrict how elements are accessed. **Use of queues makes sense when the number of elements to be stored is not known in advance and the only element that must be accessible is the remaining element that was stored earliest.**

One minor difference between `SplQueue` and `SplStack` is that the former contains two method aliases named after conceptual queue operations: [`dequeue()`](http://php.net/manual/en/splqueue.dequeue.php "PHP: SplQueue::dequeue - Manual") aliases [`SplDoublyLinkedList::shift()`](http://php.net/manual/en/spldoublylinkedlist.shift.php "PHP: SplDoublyLinkedList::shift - Manual") and [`enqueue()`](http://php.net/manual/en/splqueue.enqueue.php "PHP: SplQueue::enqueue - Manual") aliases [`SplDoublyLinkedList::push()`](http://php.net/manual/en/spldoublylinkedlist.push.php "PHP: SplDoublyLinkedList::push - Manual"). This makes sense because while `push()` and `pop()` share similar applicability to conceptual stack operations, they are already present in its parent class.

Despite their common ancestry, `SplQueue` appears to have better performance than `SplStack` as of PHP 5.3.4. Benchmarks included later in this post review this in more detail.

### Heaps

Up to this point, the data structures discussed have resembled lists insofar as they contain elements in the order in which they were added. By contrast, when an element is added to a [heap](http://en.wikipedia.org/wiki/Heap_(data_structure) "Heap (data structure) - Wikipedia, the free encyclopedia"), a comparison function is used to compare the new element to other elements already in the heap and element is placed appropriately within the heap based on that functions return value. The beauty of heaps is that their underlying algorithm does this with minimal element comparisons, so it's extremely efficient. **Using heaps makes sense when the number of elements to be stored is not known in advance and elements must be accessed in an order based on how they compare to each other.**

[`SplHeap`](http://php.net/manual/en/class.splheap.php "PHP: SplHeap - Manual") is an abstract class used to create a heap by extending it and providing a comparison function in the form of its [`compare()`](http://php.net/manual/en/splheap.compare.php "PHP: SplHeap::compare - Manual") method. Only the root element of a heap, the one yielding the highest comparison function return value, may be accessed or removed from the heap at any given time. This is done using the [`extract()`](http://php.net/manual/en/splheap.extract.php "PHP: SplHeap::extract - Manual") method of `SplHeap`. `SplHeap` implements the [`Iterator`](http://php.net/manual/en/class.iterator.php "PHP: Iterator - Manual") and [`Countable`](http://php.net/manual/en/class.countable.php "PHP: Countable - Manual") interfaces but, because only the root element can be extracted, it does not implement the [`ArrayAccess`](http://php.net/manual/en/class.arrayaccess.php "PHP: ArrayAccess - Manual") interface like the previously discussed data structure classes.

In addition to the abstract `SplHeap` class, two concrete implementations are also included in the SPL, namely [`SplMinHeap`](http://php.net/manual/en/class.splminheap.php "PHP: SplMinHeap - Manual") and [`SplMaxHeap`](http://php.net/manual/en/class.splmaxheap.php "PHP: SplMaxHeap - Manual"). The [`compare()`](http://php.net/manual/en/splminheap.compare.php "PHP: SplMinHeap::compare - Manual") method of `SplMinHeap` returns a value such that the smallest element in the heap is the root element. Likewise, the [`compare()`](http://php.net/manual/en/splmaxheap.compare.php "PHP: SplMaxHeap::compare - Manual") method of `SplMaxHeap` returns a value such that the largest element in the heap is the root element.

At first glance, using a subclass of `SplHeap` may seem equivalent to calling [`sort()`](http://php.net/sort "PHP: sort - Manual") or a similar function on an array and accessing the elements in sequence. This is indeed the case if all elements are added to the array prior to it being sorted. However, situations such as elements arriving over time or inadequate memory to store all elements simultaneously may preclude this approach. Use of arrays in such situations would require repeated resorting of the entire array as new elements are added, which is inefficient. This is why using the corresponding heap class makes a lot more sense in that situation than repeated calls to [`sort()`](http://php.net/sort "PHP: sort - Manual"), [`min()`](http://php.net/manual/en/function.min.php "PHP: min - Manual"), or [`max()`](http://php.net/manual/en/function.max.php "PHP: max - Manual"). Additionally, `SplHeap` can be used to implement the [heapsort algorithm](http://en.wikipedia.org/wiki/Heapsort "Heapsort - Wikipedia, the free encyclopedia"), which has [better worst case performance](http://en.wikipedia.org/wiki/Heapsort#Comparison_with_other_sorts "Heapsort - Wikipedia, the free encyclopedia") than the [quicksort algorithm](http://en.wikipedia.org/wiki/Quicksort "Quicksort - Wikipedia, the free encyclopedia") [implementation](https://git.php.net/?p=php-src.git;a=blob;f=Zend/zend_qsort.c;hb=1515fda4f3236d4777edcf5f71c0096dc79024b4#l56) [used by arrays](https://git.php.net/?p=php-src.git;a=blob;f=ext/standard/array.c;hb=1515fda4f3236d4777edcf5f71c0096dc79024b4#l541).

### Priority Queues

[Priority queues](http://en.wikipedia.org/wiki/Priority_queue "Priority queue - Wikipedia, the free encyclopedia") are somewhat similar to heaps. In fact, while it doesn't extend `SplHeap`, [`SplPriorityQueue`](http://php.net/manual/en/class.splpriorityqueue.php "PHP: SplPriorityQueue - Manual") does make use of a heap structure internally to implement its functionality. The difference is that the [`insert()`](http://www.php.net/manual/en/splpriorityqueue.insert.php "PHP: SplPriorityQueue::insert - Manual") method of `SplPriorityQueue` queue accepts both a value and an associated priority, removing the need to use an array or object to store both of these and define an appropriate comparison function in an `SplHeap` instance. Elements with the highest priority, like those in `SplMaxHeap` with the highest value, are the ones that come out first when [`extract()`](http://php.net/manual/en/splpriorityqueue.extract.php "PHP: SplPriorityQueue::extract - Manual") is called. Note that elements with equal priority are returned in no particular order.

For reasons similar to those of `SplHeap`, `SplPriorityQueue` implements both [`Iterator`](http://php.net/manual/en/class.iterator.php "PHP: Iterator - Manual") and [`Countable`](http://php.net/manual/en/class.countable.php "PHP: Countable - Manual") interfaces and does not implement the [`ArrayAccess`](http://php.net/manual/en/class.arrayaccess.php "PHP: ArrayAccess - Manual") interface. Because it stores a value and priority per element, `SplPriorityQueue` includes a [`setExtractFlags()`](http://php.net/manual/en/splpriorityqueue.setextractflags.php "PHP: SplPriorityQueue::setExtractFlags - Manual") method that modifies the behavior of `extract()` to return the stored value, the stored priority, or an array containing both. Priorities are not bound to a particular data type: strings, integers, or even composite data types can be used. `SplPriorityQueue` can be extended and its [`compare()`](http://www.php.net/manual/en/splpriorityqueue.compare.php "PHP: SplPriorityQueue::compare - Manual") method overridden to customize the comparison logic.

**It makes sense to use a priority queue when the number of elements to be stored is not known in advance and elements must be accessed in an order based on how a value associated with each element (versus the element value itself) compares to the same associated values of other elements.**

### Sets and Composite Hash Maps

[`SplObjectStorage`](http://php.net/manual/en/class.splobjectstorage.php "PHP: SplObjectStorage - Manual") combines some of the properties of two different data structures. First, it provides the same functionality of a [hash table](http://en.wikipedia.org/wiki/Hash_table "Hash table - Wikipedia, the free encyclopedia") that a normal array has, but without its associated inability to use objects as keys unless the [`spl_object_hash()`](http://php.net/spl_object_hash "PHP: spl_object_hash - Manual") function is used. In other words, it implements a composite hash map. Second, it can be used as a [set](http://en.wikipedia.org/wiki/Set_(computer_science) "Set (computer science) - Wikipedia, the free encyclopedia") to store objects as data without a meaningful corresponding key or concept of sequential order.

Its [`attach()`](http://php.net/manual/en/splobjectstorage.attach.php "PHP: SplObjectStorage::attach - Manual") method accepts an object key and the data to associate with it and its [`detach()`](http://php.net/manual/en/splobjectstorage.detach.php "PHP: SplObjectStorage::detach - Manual") method allows data to be removed using its associated object key. To use the object as a set, simply exclude the `$data` parameter for `attach()`, as it's optional. The [set operations](http://en.wikipedia.org/wiki/Set_(computer_science)#Operations "Set (computer science) - Wikipedia, the free encyclopedia") implemented by `SplObjectStorage` all have array function counterparts. For example, the [`addAll()`](http://php.net/manual/en/splobjectstorage.addall.php "PHP: SplObjectStorage::addAll - Manual") method and [`array_merge()`](http://php.net/manual/en/function.array-merge.php "PHP: array_merge - Manual") function both correspond to the union set operation. The difference operation is available using the [`removeAll()`](http://php.net/manual/en/splobjectstorage.removeall.php "PHP: SplObjectStorage::removeAll - Manual") method and [`array_diff()`](http://php.net/manual/en/function.array-diff.php "PHP: array_diff - Manual") function and its variants. The [`contains()`](http://php.net/manual/en/splobjectstorage.contains.php "PHP: SplObjectStorage::contains - Manual") method and [`in_array()`](http://php.net/manual/en/function.in-array.php "PHP: in_array - Manual") function both implement the `element_of` operation. Sadly, only arrays have an implementation of the intersection operation in the form of [`array_intersect()`](http://php.net/manual/en/function.array-intersect.php "PHP: array_intersect - Manual") and its variants. Tobias Schlitt has a [more in-depth analysis](http://schlitt.info/opensource/blog/0722_python_good_bad_evil_02_native_sets.html "Python. Good, bad, evil -2-: Native sets - Blog - Open Source - schlitt.info") of this data structure that includes implementations of the set operations lacking in the SPL itself.

**Update: A patch I've submitted has been [merged](http://news.php.net/php.cvs/64274 "php.cvs: svn:_/php/php-src/_branches/PHP_5_3/ext/spl/spl_observer.c_branches/PHP_5_3/ext/spl/tests/SplObjectStorage_removeAllExcept_basic.phpt_branches/PHP_5_3/ext/spl/tests/SplObjectStorage_removeAllExcept_invalid_parameter.phpt_trunk/ext/spl/spl_observer.c_trunk/ext/spl/tests/SplObjectStorage_removeAllExcept_basic.phpt_trunk/ext/spl/tests/SplObjectStorage_removeAllExcept_invalid_parameter.phpt"). [SplObjectStorage::removeAllExcept()](http://php.net/manual/en/splobjectstorage.removeallexcept.php "PHP: SplObjectStorage::removeAllExcept - Manual"), which is equivalent to the set intersection operation, will become available in PHP 5.3.5. (1/5/2011)**

Like some of the other data structures in the SPL, `SplObjectStorage` implements the [`Iterator`](http://php.net/manual/en/class.iterator.php "PHP: Iterator - Manual"), [`Countable`](http://php.net/manual/en/class.countable.php "PHP: Countable - Manual"), and [`ArrayAccess`](http://php.net/manual/en/class.arrayaccess.php "PHP: ArrayAccess - Manual") interfaces. Oddly, it also implements the [`Traversable`](http://php.net/manual/en/class.traversable.php "PHP: Traversable - Manual") interface (which is limited to internally defined classes and negates the need for implementation of the `Iterator` interface) and the [`Serializable`](http://php.net/manual/en/class.serializable.php "PHP: Serializable - Manual") interface (and it is the only SPL data structure class to do so).

**Using this class makes sense when data must be stored using composite keys or the ability to access data using set operations is more important than accessing data in a specific order.**

### Benchmarks

_Standard disclaimer: There are [lies, damned lies, and benchmarks](http://en.wikipedia.org/wiki/Lies,_damned_lies,_and_statistics "Lies, damned lies, and statistics - Wikipedia, the free encyclopedia"). [<acronym title="Your Mileage May Vary">YMMV</acronym>](http://en.wiktionary.org/wiki/your_mileage_may_vary "your mileage may vary - Wiktionary")._

Code and instructions are located in [this GitHub repository](https://github.com/elazar/spl-benchmarks "elazar's spl-benchmarks at master - GitHub").

**Update: I've removed benchmark result charts generated on my system from this post. I encourage you to run the benchmarks yourself to get your own results. (4/14/2015)**

### Other Data Structures

If you have an interest in other data structure implementations for PHP outside of SPL offerings, check out the [bloomy](http://pecl.php.net/package/bloomy "PECL :: Package :: bloomy") [PECL](http://pecl.php.net/ "PECL :: The PHP Extension Community Library") extension, which is an implementation of a [bloom filter](http://en.wikipedia.org/wiki/Bloom_filter "Bloom filter - Wikipedia, the free encyclopedia") created by [Andrei Zmievski](http://zmievski.org/2009/04/bloom-filters-quickie "Bloom Filters Quickie - Andrei Zmievski").